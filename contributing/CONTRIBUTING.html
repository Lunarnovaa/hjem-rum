<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Contributing</title>
    <script>
      // Apply sidebar state immediately to prevent flash
      (function () {
        if (localStorage.getItem("sidebar-collapsed") === "true") {
          document.documentElement.classList.add("sidebar-collapsed");
        }
      })();
    </script>
    <link rel="stylesheet" href="assets/style.css" />
    <script defer src="assets/main.js"></script>
    
    <script defer src="assets/search.js"></script>
    
  </head>
  <body>
    <div class="container">
      <header>
        <div class="header-left">
          <h1 class="site-title"><a href="index.html">Hjem Rum</a></h1>
        </div>
        <nav class="header-nav">
          <ul>
            <li ><a href="options.html">Options</a></li>
            
            <li><a href="search.html">Search</a></li>
            
          </ul>
        </nav>
        
        <div class="search-container">
          <input type="text" id="search-input" placeholder="Search..." />
          <div id="search-results" class="search-results"></div>
        </div>
        
      </header>

      <div class="layout">
        <div class="sidebar-toggle" aria-label="Toggle sidebar">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            width="24"
            height="24"
          >
            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
          </svg>
        </div>
        <nav class="sidebar">
          <div class="docs-nav">
            <h2>Documents</h2>
            <ul>
              <li><a href="index.html">Hjem Rum</a></li>
<li><a href="contributing/REVIEWING.html">Review Tips</a></li>
<li><a href="contributing/TESTING.html">Testing setup for modules</a></li>
<li><a href="contributing/CONTRIBUTING.html">Contributing</a></li>
<li><a href="usage/QUIRKS.html">Quirks, Tips, & Tricks</a></li>
<li><a href="usage/INSTALLATION.html">Installing Hjem Rum</a></li>
<li><a href="search.html">Search</a></li>

            </ul>
          </div>

          <div class="toc">
            <h2>Contents</h2>
            <ul class="toc-list">
              <li><a href="#contributing">Contributing</a>
<ul><li><a href="#ch-getting-started">Getting Started</a>
<ul><li><a href="#sec-commit-format">Commit Format</a>
</ul><li><a href="#ch-core-principles">Core Principles</a>
<li><a href="#ch-guidelines">Guidelines</a>
<ul><li><a href="#sec-aliases">Aliases</a>
<li><a href="#sec-writing-options">Writing Options</a>
<li><a href="#sec-conditionals-in-modules">Conditionals in Modules</a>
<li><a href="#sec-extending-rumlib">Extending RumLib</a>
<li><a href="#sec-docs">Docs</a>
<li><a href="#sec-tests">Tests</a>
</ul><li><a href="#ch-reviewing-a-pr">Reviewing a PR</a>
</li></ul></li>
            </ul>
          </div>
        </nav>

        <main class="content">
          <h1 id="contributing">Contributing</h1>
<p>Hjem Rum (or HJR) is always in need of contributions as a module collection. As
programs are developed, modules will need to be added, changed, removed, etc.,
meaning that the development of HJR is, in essence, unending.</p>
<p>Contributing is also a great way to learn the Nix module system and even
function writing. Don't be afraid to experiment and try learning something new.</p>
<p>If you are familiar with contributing to open source software, you can safely
skip ahead to <a href="#ch-core-principles">Core Principles</a>. Otherwise, read the following section to learn
how to fork a repo and open a PR.</p>
<h2 id="ch-getting-started">Getting Started</h2>
<p>To begin contributing to HJR, you will first need to create a fork off of the
main branch in order to make changes. For info on how to do this, we recommend
GitHub's own <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo">documentation on forking repositories</a>.</p>
<p>Once you have your own fork, it is recommend that you create a branch for the
changes or additions you seek to make, to make it easier to set up multiple PRs
from your fork. To do so, you can read this <a href="https://www.geeksforgeeks.org/how-to-create-a-new-branch-in-git/">article from GeeksforGeeks</a> that
will also explain branches for you. Don't worry too much about the technical
details, the most important thing is to make and switch to a branch from HEAD.</p>
<h3 id="sec-commit-format">Commit Format</h3>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Our dev shell allows for interactive commits, through the means of
[commitizen]. If this is preferred, you can run <code>cz commit</code> to be prompted to
build your commit.</p>
</div>
<p>For consistency, we do enforce a strict (but simple) commit style, that will be
linted against. The format is as follows (sections between <code>[]</code> are optional):</p>
<pre><code class="language-console">&lt;top_level_scope&gt;[/&lt;specific_scope&gt;]: &lt;message&gt;

[&lt;body&gt;]
</code></pre><ul>
<li><p>&lt;top_level_scope&gt;: the main scope of your commit. If making a change to a
program, this would be <code>programs</code>). For changes unrelated to the modules API,
we tend to use semantic scopes such as <code>meta</code> for CI/repo related changes.</p>
</li>
<li><p>[&lt;specific_scope&gt;]: An optional, more specific scope for your module. If
making changes to a specific program, this would be <code>programs/foot</code>.</p>
</li>
<li><p>&lt;message&gt;: A free form commit message. Needs to be imperative and without
punctuation (e.g. <code>do stuff</code> instead of <code>did stuff.</code>).</p>
</li>
<li><p>[&lt;body&gt;]: A free form commit body. Having one is encouraged when your
changes are difficult to explain, unless you're writing in-depth code comments
(it is still preferred however).</p>
</li>
</ul>
<p>You can now make your changes in your editor of choice. After committing your
changes, you can run:</p>
<pre><code class="language-shell">git push origin &lt;branch-name&gt;
</code></pre><p>and then open up a PR, or "Pull Request," in the upstream HJR repository. Again,
GitHub has good documentation for <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request">creating a PR</a>.</p>
<p>After you have setup a PR, it will be <a href="#ch-reviewing-a-pr">reviewed</a> by maintainers and changes may
be requested. Make the changes requested and eventually it will likely be
accepted and merged into main.</p>
<h2 id="ch-core-principles">Core Principles</h2>
<p>In creating HJR, we had a few principles in mind for development:</p>
<ol>
<li>Minimize the number of options written.</li>
<li>Include only the module collection - leave functionality to Hjem.</li>
<li>Maintain readability of code, even for new users.</li>
</ol>
<p>Please keep these in mind as you read through our general guidelines for
contributing.</p>
<h2 id="ch-guidelines">Guidelines</h2>
<p>These guidelines, are, of course, merely guidelines. There are and will continue
to be exceptions. However, do your best to stick to them, and keep in mind that
reviewers will hold you to them as much as possible.</p>
<h3 id="sec-aliases">Aliases</h3>
<p>At the top of any module, there should always be a <code>let ... in</code> set. Within
this, functions should have their location aliased, cfg should be aliased, and
any generators should have an alias as well. Here's an example for a module that
makes use of the TOML generator used in Nixpkgs:</p>
<pre><code class="language-nix">{
  config,
  lib,
  pkgs,
  ...
}: let
  # in case you are unfamiliar, &#39;inherit func;&#39; is the same as &#39;func = func;&#39;, and
  # &#39;inherit (cfg) func;&#39; is the same as &#39;func = cfg.func;&#39;
  inherit (lib.modules) mkIf;
  inherit (lib.options) mkOption mkEnableOption mkPackageOption;

  toml = pkgs.formats.toml {};

  cfg = config.rum.programs.alacritty;
in {
  options.rum.programs.alacritty = {
</code></pre><p>Notice that each function has its location aliased with an inherit to its target
location. Ideally, this location should be where one could find it in the source
code. For example, rather than using <code class="file-path">lib.mkIf</code>, we use
<code class="file-path">lib.modules.mkIf</code>, because mkIf is declared at <code>lib/modules.nix</code> within
the Nixpkgs repo.</p>
<p>Also notice that in this case, <code>pkgs.formats.toml {}</code> includes both <code>generate</code>
and <code>type</code>, so the alias name is just <code>toml</code>.</p>
<p>Always be sure to include <code>cfg</code> that links to the point where options are
configured by the user.</p>
<h3 id="sec-writing-options">Writing Options</h3>
<p>Writing new options is the core of any new module. It is also the easiest place
to blunder. As stated above, a core principle of HJR is to minimize the number
of options as much as possible. As such, we have created a general template that
should help inform you of what options are needed and what are not:</p>
<ul>
<li><code>enable</code>: Used to toggle install and configuration of package(s).</li>
<li><code>package</code>: Used to customize and override the package installed.<ul>
<li>As needed, <code>packages</code>: List of packages used in a module.</li>
</ul>
</li>
<li><code>settings</code>: Primary configuration option, takes Nix code and converts to
target lang.<ul>
<li>As needed, one extra option for each extra file, such as <code>theme</code> for
theme.toml.</li>
</ul>
</li>
<li>As needed, <code>extraConfig</code>: Extra lines of strings passed directly to config
file for certain programs.</li>
</ul>
<p>For the most part, this should be sufficient. Overrides of packages should be
simply offered through a direct override in <code>package</code>. For example, ncmpcpp's
package has a <code>withVisualizer ? false</code> argument. Rather than creating an extra
option for this, the contributor should note this with <code>extraDescription</code>, and
give an example of it like so:</p>
<pre><code class="language-nix">options.rum.programs.ncmpcpp = {
  enable = mkEnableOption &quot;ncmpcpp, a mpd-based music player.&quot;;

  package = mkPackageOption pkgs &quot;ncmpcpp&quot; {
    extraDescription = &#39;&#39;
        You can override the package to customize certain settings that are baked
        into the package.
    &#39;&#39;;
    # Note that mkPackageOption&#39;s example automatically uses literalExpression
    example = &#39;&#39;
        pkgs.ncmpcpp.override {
            # useful overrides in the package
            outputsSupport = true; # outputs screen
            visualizerSupport = false; # visualizer screen
            clockSupport = true; # clock screen
            taglibSupport = true; # tag editor
        };
    &#39;&#39;;
  };
</code></pre><p>and the user could simply pass:</p>
<pre><code class="language-nix">config.hjem.users.&lt;username&gt;.rum.programs.ncmpcpp = {
    enable = true;
    package = (pkgs.ncmpcpp.override {
        withVisualizer = true;
    });
};
</code></pre><p>The <code>type</code> of <code>settings</code> and other conversion options should preferably be a
<code>type</code> option exposed by the generator (for example, TOML has
<code>pkgs.formats.toml {}.type</code> and <code>pkgs.formats.toml {}.generate</code>), or, if using a
custom generator, a <code>type</code> should be created in <code>lib/types/</code> (for example,
<code>hyprType</code>). Otherwise, a simple <code>attrsOf anything</code> would suffice.</p>
<p>As a rule of thumb, submodules should not be employed. Instead, there should
only be one option per file. For some files, such as spotify-player's
<code class="file-path">keymap.toml</code>, you may be tempted to create multiple options for <code>actions</code>
and <code>keymaps</code>, as Home Manager does. Please avoid this. In this case, we can
have a simple <code>keymap</code> option that the user can then include a list of keymaps
and/or a list of actions that get propagated accordingly:</p>
<pre><code class="language-nix">  keymap = mkOption {
    inherit (toml) type; # We can use a streamlined inherit to say type = toml.type
    default = {};
    example = {
      keymaps = [
        {
          command = &quot;NextTrack&quot;;
          key_sequence = &quot;g n&quot;;
        }
      ];
      actions = [
        {
          action = &quot;GoToArtist&quot;;
          key_sequence = &quot;g A&quot;;
        }
      ];
    };
    description = &#39;&#39;
      Sets of keymaps and actions converted into TOML and written to
      &lt;code class=&quot;file-path&quot;&gt;$HOME/.config/spotify-player/keymap.toml&lt;/code&gt;.
      See example for how to format declarations.

      Please reference <a href="https://github.com/aome510/spotify-player/blob/master/docs/config.md#keymaps">https://github.com/aome510/spotify-player/blob/master/docs/config.md#keymaps</a>
      for more information.
    &#39;&#39;;
  };
</code></pre><p>Also note that the option description includes a link to upstream info on
settings options.</p>
<p>If an option is dependent on <code>config</code>, (e.g.
<code>default = config.myOption.enable;</code>) you must <em>also</em> set <code>defaultText</code> alongside
<code>default</code>. Example:</p>
<pre><code class="language-nix">integrations = {
    # We basically override the `default` and `defaultText` attrs in the mkEnableOption function
    fish.enable = mkEnableOption &quot;starship integration with fish&quot; // {
        default = config.programs.fish.enable;
        defaultText = &quot;config.programs.fish.enable&quot;;
    };
};
</code></pre><p>It is essentially just a string that shows the user what the option is set to by
default. This can also be used in <code>mkOption</code>, but it is more common to use it in
<code>mkEnableOption</code>.</p>
<p>If you do not set this, the docs builder will break due to not knowing how to
resolve the reference to <code>config</code>.</p>
<h3 id="sec-conditionals-in-modules">Conditionals in Modules</h3>
<p>Always use a <code>mkIf</code> before the <code>config</code> section. Example:</p>
<pre><code class="language-nix">config = mkIf cfg.enable {
    ...
};
</code></pre><p>As a general guideline, <strong>do not write empty strings to files</strong>. Not only is
this poorly optimized, but it will cause issues if a user happens to be manually
using the Hjem tooling alongside HJR. Here are some examples of how you might
avoid this:</p>
<pre><code class="language-nix">config = mkIf cfg.enable {
  packages = [cfg.package];
  files.&quot;.config/alacritty/alacritty.toml&quot;.source = mkIf (cfg.settings != {}) (
    toml.generate &quot;alacritty.toml&quot; cfg.settings # The indentation makes it more readable
  );
};
</code></pre><p>Here all that is needed is a simple <code>mkIf</code> with a condition of the <code>settings</code>
option not being left empty. In a case where you write to multiple files, you
can use <code>optionalAttrs</code>, like so:</p>
<pre><code class="language-nix">files = (
    optionalAttrs (cfg.settings != {}) {
    &quot;.gtkrc-2.0&quot;.text = toGtk2Text {inherit (cfg) settings;};
    &quot;.config/gtk-3.0/settings.ini&quot;.text = toGtkINI {Settings = cfg.settings;};
    &quot;.config/gtk-4.0/settings.ini&quot;.text = toGtkINI {Settings = cfg.settings;};
    }
    // optionalAttrs (cfg.css.gtk3 != &quot;&quot;) {
    &quot;.config/gtk-3.0/gtk.css&quot;.text = cfg.css.gtk3;
    }
    // optionalAttrs (cfg.css.gtk4 != &quot;&quot;) {
    &quot;.config/gtk-4.0/gtk.css&quot;.text = cfg.css.gtk4;
    }
);
</code></pre><p>This essentially takes the attribute set of <code>files</code> and <em>conditionally</em> adds
attributes defining more files to be written to depending on <em>if</em> the
corresponding option has been set. This is optimal because the first three files
written to share an option due to how GTK configuration works.</p>
<p>One last case is in the Hyprland module, where several checks and several
options are needed to compile into one file. Here is how it is done:</p>
<pre><code class="language-nix">files = let
  check = {
    plugins = cfg.plugins != [];
    settings = cfg.settings != {};
    variables = {
      noUWSM = config.environment.sessionVariables != {} &amp;&amp; !osConfig.programs.hyprland.withUWSM;
      withUWSM = config.environment.sessionVariables != {} &amp;&amp; osConfig.programs.hyprland.withUWSM;
    };
    extraConfig = cfg.extraConfig != &quot;&quot;;
  };
in {
  &quot;.config/hypr/hyprland.conf&quot;.text = mkIf (check.plugins || check.settings || check.variables.noUWSM || check.extraConfig) (
    optionalString check.plugins (pluginsToHyprconf cfg.plugins cfg.importantPrefixes)
    + optionalString check.settings (toHyprconf {
      attrs = cfg.settings;
      inherit (cfg) importantPrefixes;
    })
    + optionalString check.variables.noUWSM (toHyprconf {
      attrs.env =
        # <a href="https://wiki.hyprland.org/Configuring/Environment-variables/#xdg-specifications">https://wiki.hyprland.org/Configuring/Environment-variables/#xdg-specifications</a>
        [
          &quot;XDG_CURRENT_DESKTOP,Hyprland&quot;
          &quot;XDG_SESSION_TYPE,wayland&quot;
          &quot;XDG_SESSION_DESKTOP,Hyprland&quot;
        ]
        ++ mapAttrsToList (key: value: &quot;${key},${value}&quot;) config.environment.sessionVariables;
    })
    + optionalString check.extraConfig cfg.extraConfig
  );

  /*
  uwsm environment variables are advised to be separated
  (see <a href="https://wiki.hyprland.org/Configuring/Environment-variables/">https://wiki.hyprland.org/Configuring/Environment-variables/</a>)
  */
  &quot;.config/uwsm/env&quot;.text =
    mkIf check.variables.withUWSM
    (toEnvExport config.environment.sessionVariables);

  &quot;.config/uwsm/env-hyprland&quot;.text = let
    /*
    this is needed as we&#39;re using a predicate so we don&#39;t create an empty file
    (improvements are welcome)
    */
    filteredVars =
      filterKeysPrefixes [&quot;HYPRLAND_&quot; &quot;AQ_&quot;] config.environment.sessionVariables;
  in
    mkIf (check.variables.withUWSM &amp;&amp; filteredVars != {})
    (toEnvExport filteredVars);
};
</code></pre><p>An additional attribute set of boolean aliases is set within a <code>let ... in</code> set
to highlight the different checks done and to add quick ways to reference each
check without excess and redundant code.</p>
<p>First, the file is only written if any of the options to write to the file are
set. <code>optionalString</code> is then used to compile each option's results in an
optimized and clean way.</p>
<h3 id="sec-extending-rumlib">Extending RumLib</h3>
<p>Rather than having functions scattered throughout the module collection, we
would rather keep our directories organized and purposeful. Therefore, all
custom functions should go into our extended lib, found at <code>modules/lib/</code>.</p>
<p>The most common functions that might be created are a <code>generator</code> and <code>type</code>
pair. The former should be prefixed with "to" to maintain style and describe
their function: conversion <em>to</em> other formats. For example, <code>toNcmpcppSettings</code>
is the function that converts to the format required for ncmpcpp settings.</p>
<p>Likewise, types should be suffixed with "Type" to maintain style and describe
their function. For example, <code>hyprType</code> describes the type used in <code>settings</code>
converted to Hyprlang.</p>
<p>When it comes to directory structure, you should be able to infer how we
organize our lib by both our folder structure itself as well as the names of
functions. For example, <code class="nixos-option">rumLib.types.gtkType</code> is found in
<code>lib/types/gtkType.nix</code>. In cases where a file is a single function, always be
sure to make sure the name matches the file.</p>
<p>If a program uses multiple functions of the same kind (e.g. two generators), you
can put them in one file, like is done in <code>lib/generators/gtk.nix</code>.</p>
<p>Additionally, please follow how lib is structured in Nixpkgs. For example, the
custom function <code>attrsNamesHasPrefix</code> is under <code>attrsets</code> to signify that it
operates on an attribute set, just like in Nixpkgs.</p>
<h3 id="sec-docs">Docs</h3>
<p>If you would like to contribute to our documentation, we ask a few things of
you:</p>
<ol>
<li>Please aim to write in a formal tone.</li>
<li>Use proper grammar and check for misspellings or typos.</li>
<li>Try to be concise, but also explain things in full.</li>
</ol>
<p>In general, the requirements are very loose, but maintainers may have more
specific asks of you depending on the case. Writing can be very personal and
very fluid, so there are less rigid expectations here, but that does not mean
standards are lower.</p>
<p>If you are including an option or function labeled like:</p>
<pre><code class="language-md">Make sure to use `lib.options.mkEnableOption`, like is done in
`rum.programs.fish.enable`
</code></pre><p>Then you will have to include {file} before it, or {option} if it is an option:<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-md">Make sure to use &lt;code class=&quot;file-path&quot;&gt;lib.options.mkEnableOption&lt;/code&gt;, like is done in
&lt;code class=&quot;nixos-option&quot;&gt;rum.programs.fish.enable&lt;/code&gt;.
</code></pre><div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup><p>It is admittedly a bit confusing why we could use {file} for <code>lib</code>, but
the best way to think of it is that <code class="file-path">lib.modules.mkIf</code> literally
corresponds to file <code class="file-path">lib/modules.nix</code> in Nixpkgs, which contains the
<code>mkIf</code> function.</p>
</div>
<p>If you do not do it like this, the link check on the docs will fail, since our
docs generator will attempt to make hyperlinks out of those function names.</p>
<p>Headers should always have an anchor with them to ensure the link checker can
follow header links at time of build. Follow these examples, and you should find
it simple:</p>
<pre><code class="language-md"># My new document page {#my-new-document-page}

## My 1st chapter heading! {#ch-my-1st-chapter-heading}

### WHAT_DI-887-NI-DO&gt;????? WRONG ? my cool section! {#sec-what-di-887-ni-do-wrong-my-cool-section}
</code></pre><p>Words should be separated by <code>-</code>, special characters should be removed, numbers
are fine to keep, extra spaces should be removed, everything should be lower
caps, first headings have no prefix, second headings have <code>ch</code> prefix, third
headings have <code>sec</code> prefix, etc. If you're unsure, just give it your best shot
and a reviewer will make sure it's as it should be.</p>
<h3 id="sec-tests">Tests</h3>
<p>Please refer to the <a href="./TESTING.html">testing documentation</a> for more information on how tests
work.</p>
<h2 id="ch-reviewing-a-pr">Reviewing a PR</h2>
<p>Even if you do not have write-access, you can always leave a review on someone
else's PR. Again, GitHub has great <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request">documentation on reviewing PRs</a>. This is
great practice for learning the guidelines as well as learning exceptions to the
rules. For some guidelines on review practices, see <a href="./REVIEWING.html">REVIEWING.md</a>.</p>

          <div class="footnotes-container">
            <!-- Footnotes will be appended here -->
          </div>
        </main>
      </div>

      <footer>
        <p>$footer</p>
      </footer>
    </div>

    <script src="assets/search.js"></script>

  </body>
</html>
